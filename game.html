<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Manches — PirateFx</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#1e3a8a">
<style>
  :root{--card:rgba(255,255,255,0.06);--accent:#0ea5e9;--muted:#9ca3af;--white:#eef2ff;--disabled:rgba(255,255,255,0.18)}
  *{box-sizing:border-box}
  body{margin:0;min-height:100vh;background:linear-gradient(180deg,#041226,#071430) fixed;background-repeat:no-repeat;background-size:cover;background-position:center;font-family:system-ui;color:var(--white);padding:14px}
  .wrap{max-width:900px;margin:0 auto}
  .card{background:var(--card);padding:14px;border-radius:14px;border:1px solid rgba(255,255,255,0.08)}
  .top{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h2{margin:0;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .players{display:flex;flex-direction:column;gap:10px}
  .player{display:flex;align-items:center;gap:12px;padding:10px;border-radius:12px;background:rgba(255,255,255,0.03)}
  .name{flex:1;font-weight:800}
  .btns{display:flex;gap:6px;flex-wrap:wrap}
  .choice{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:var(--white);cursor:pointer;font-weight:800}
  .choice.active{background:var(--accent);color:#021026}
  .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
  .btn{padding:12px;border-radius:12px;border:0;background:var(--accent);color:#021026;font-weight:800;cursor:pointer}
  .btn.disabled{background:var(--disabled);color:#cbd5e1;cursor:not-allowed}
  .abo{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:40px;text-align:center}
  .btn.ghost-secondary {background: transparent;border: 2px solid rgba(255,255,255,0.06);color: var(--white);font-weight:800;padding:10px 12px;border-radius:12px;}
  .btn.primary { background: var(--accent); color:#021026; font-weight:900; }
  .btn.disabled { background: var(--disabled); color:#cbd5e1; cursor:not-allowed; }

  .round-start { display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; padding:28px; }
  .round-number { font-size:72px; font-weight:900; letter-spacing:-2px; }
  .round-label { font-size:18px; color:var(--muted); text-transform:uppercase; letter-spacing:2px; }

  .starter-badge { padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:800;color:var(--muted);display:inline-block;margin-left:8px;font-size:13px }
  @media(max-width:600px){ .round-number{font-size:48px} .choice{padding:8px 10px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="top">
        <h2 id="hdr">Manche</h2>
        <div class="muted" id="info"></div> <!-- laissé vide par design -->
      </div>

      <div id="content"></div>
    </div>
  </div>

<script>
const LS_GAME = 'skullking_game_v0.21';
const LS_LEADER = 'skullking_leaderboard_v0.21';

function loadGame(){ return JSON.parse(localStorage.getItem(LS_GAME) || 'null'); }
function saveGame(g){ localStorage.setItem(LS_GAME, JSON.stringify(g)); }
function loadLB(){ return JSON.parse(localStorage.getItem(LS_LEADER) || '{}'); }
function saveLB(lb){ localStorage.setItem(LS_LEADER, JSON.stringify(lb)); }

function delta(bid,made,round){
  bid=+bid; made=+made; round=+round;
  if (made===bid){ return bid===0 ? round*10 : bid*20; }
  return bid===0 ? -round*10 : -Math.abs(made-bid)*10;
}

let game = loadGame();
if (!game || !game.players || !game.players.length){ alert('Aucune partie trouvée.'); location.href='create.html'; }

const hdr = document.getElementById('hdr');
const info = document.getElementById('info'); // will be left empty per your request
const content = document.getElementById('content');

function subphase(){ return game.subphase || 'bids'; }

// helper: find player index by id
function findPlayerIndexById(id){
  return game.players.findIndex(p => (p.id ?? p.name) === id);
}

// starter index for an arbitrary round number (roundNumber is 1-based)
function getStarterIndexForRound(roundNumber){
  const n = game.players.length;
  if (n === 0) return 0;
  // initial starter id (if none, default to first player index 0)
  const startId = game.startPlayerId ?? (game.players[0] && (game.players[0].id ?? game.players[0].name));
  const initIdx = findPlayerIndexById(startId);
  const base = initIdx >= 0 ? initIdx : 0;
  // rotate by roundNumber-1 (because round 1 => base, round 2 => base+1, etc.)
  return (base + (roundNumber - 1)) % n;
}

// build order array starting from starterIdx: [starter, next, ...]
function buildOrderFromStarter(starterIdx){
  const n = game.players.length;
  const order = [];
  for (let i=0;i<n;i++){
    order.push(game.players[(starterIdx + i) % n]);
  }
  return order;
}

function render(){
  hdr.textContent = `Manche ${game.currentRound} / ${game.totalRounds}`;
  // remove players count display as requested
  info.textContent = '';

  const phase = subphase();
  content.innerHTML = '';

  const phaseTitle = document.createElement('div');
  phaseTitle.style.fontSize = '18px';
  phaseTitle.style.fontWeight = '900';
  phaseTitle.style.marginBottom = '10px';
  phaseTitle.style.alignItems = 'center';
  if (phase === 'bids') phaseTitle.textContent = 'CHOISISSEZ VOS PARIS';
  else if (phase === 'ready') phaseTitle.textContent = "À L'ABORDAGE — Prêt ?"
  else if (phase === 'round_start') phaseTitle.textContent = '';
  else phaseTitle.textContent = 'ENTREZ LES PLIS RÉALISÉS';
  content.appendChild(phaseTitle);

  // compute starter details to show when needed (for current round)
  const starterIdx = getStarterIndexForRound(game.currentRound);
  const starterPlayer = game.players[starterIdx];
  const starterName = starterPlayer ? starterPlayer.name : '';

  if (phase === 'bids'){
    // Phase PARIS -> show players in order starting from starter (rotates each round)
    const playersBox = document.createElement('div'); playersBox.className='players';
    game.tempBids = game.tempBids || {};

    // create order starting at starter for current round
    const order = buildOrderFromStarter(starterIdx);

    // show small badge indicating who starts (without "Commence")
    const infoLine = document.createElement('div');
    infoLine.className = 'muted';
    infoLine.innerHTML = `Starter : <strong>${escapeHtml(starterName)}</strong>`; // badge removed

    // append info then players list (fixed insertion order)
    content.appendChild(infoLine);

    for (const p of order){
      const row = document.createElement('div'); row.className='player';
      const name = document.createElement('div'); name.className='name'; name.textContent=p.name;
      row.appendChild(name);
      const btns = document.createElement('div'); btns.className='btns';
      for (let i=0;i<=game.currentRound;i++){
        const b = document.createElement('button'); b.className='choice'+((game.tempBids[p.id]??0)===i?' active':''); b.textContent=String(i);
        b.addEventListener('click', ()=>{ game.tempBids[p.id]=i; saveGame(game); render(); });
        btns.appendChild(b);
      }
      row.appendChild(btns); playersBox.appendChild(row);
    }
    content.appendChild(playersBox);

    const actions = document.createElement('div'); actions.className='actions';
    const valid = document.createElement('button'); valid.className='btn'; valid.textContent='Valider les paris';
    valid.onclick = ()=>{
      const bids = {};
      for (const p of game.players) bids[p.id] = Number((game.tempBids && game.tempBids[p.id]!==undefined)?game.tempBids[p.id]:0);
      game.savedBids = game.savedBids || {};
      game.savedBids[game.currentRound] = bids;
      game.subphase = 'ready'; // page intermédiaire
      game.tempMade = {};
      saveGame(game); render();
    };
    actions.appendChild(valid);
    content.appendChild(actions);

  } else if (phase === 'ready'){
    // Page intermédiaire "À L'ABORDAGE" -> show who will start and allow continue/back
    const abo = document.createElement('div'); abo.className='abo';
    const t = document.createElement('div');
    t.innerHTML = `<h3 style="margin:0">À L’ABORDAGE !</h3>
                   <div class="muted">Les paris sont verrouillés. Jouez les manches dès à présent.</div>`;
    const infoStarter = document.createElement('div');
    infoStarter.style.marginTop='8px';
    infoStarter.innerHTML = `<div style="font-weight:900">${escapeHtml(starterName)}</div><div class="muted">Commence cette manche</div>`;
    const go = document.createElement('button'); go.className='btn primary'; go.textContent='Entrer les points';
    go.onclick = ()=>{ game.subphase='made'; saveGame(game); render(); };
    const back = document.createElement('button'); back.className='btn ghost-secondary'; back.textContent='Modifier les paris';
    back.onclick = ()=>{ delete game.savedBids[game.currentRound]; game.subphase='bids'; saveGame(game); render(); };
    abo.appendChild(t); abo.appendChild(infoStarter); abo.appendChild(go); abo.appendChild(back);
    content.appendChild(abo);

  } else if (phase === 'round_start'){
    // interstitial page showing next round number & who will start it (rotated)
    const roundNum = game.nextRound ?? (game.currentRound + 1);
    const box = document.createElement('div'); box.className = 'round-start';
    const label = document.createElement('div'); label.className='round-label'; label.textContent = 'Prochaine manche';
    const big = document.createElement('div'); big.className='round-number'; big.textContent = `#${roundNum}`;
    // compute starter for next round (rotated)
    const starterForNextIdx = getStarterIndexForRound(roundNum);
    const starterForNext = game.players[starterForNextIdx];
    const starterText = starterForNext ? starterForNext.name : '';
    const infoLine = document.createElement('div'); infoLine.className='muted'; infoLine.innerHTML = `Starter : <strong>${escapeHtml(starterText)}</strong>`;
    const startBtn = document.createElement('button'); startBtn.className='btn primary'; startBtn.textContent = `Commencer la manche ${roundNum}`;
    startBtn.onclick = ()=> {
      game.currentRound = roundNum;
      game.subphase = 'bids';
      game.tempBids = {}; game.tempMade = {};
      saveGame(game); render();
    };
    const back = document.createElement('button'); back.className='btn ghost-secondary'; back.textContent = 'Annuler';
    back.onclick = ()=> { game.subphase='bids'; saveGame(game); render(); };
    box.appendChild(label); box.appendChild(big); box.appendChild(infoLine); box.appendChild(startBtn); box.appendChild(back);
    content.appendChild(box);

  } else {
    // Phase PLIS RÉALISÉS
    const playersBox = document.createElement('div'); playersBox.className='players';
    game.tempMade = game.tempMade || {};
    for (const p of game.players){
      const row = document.createElement('div'); row.className='player';
      const name = document.createElement('div'); name.className='name'; name.textContent=p.name;
      row.appendChild(name);
      const btns = document.createElement('div'); btns.className='btns';
      for (let i=0;i<=game.currentRound;i++){
        const b = document.createElement('button'); b.className='choice'+((game.tempMade[p.id]??0)===i?' active':''); b.textContent=String(i);
        b.addEventListener('click', ()=>{ game.tempMade[p.id]=i; saveGame(game); updateValidateBtn(); render(); });
        btns.appendChild(b);
      }
      row.appendChild(btns); playersBox.appendChild(row);
    }
    content.appendChild(playersBox);

    const actions = document.createElement('div'); actions.className='actions';
    const back = document.createElement('button'); back.className='btn ghost-secondary'; back.textContent='Retour (paris)';
    back.onclick = ()=>{ game.subphase='bids'; delete game.savedBids[game.currentRound]; saveGame(game); render(); };
    const valid = document.createElement('button'); valid.id='vbtn'; valid.className='btn primary disabled'; valid.textContent='Valider les plis';
    valid.disabled = true;
    valid.onclick = ()=>{
      if (valid.disabled) return;
      const bids = game.savedBids[game.currentRound] || {};
      // appliquer scores
      for (const p of game.players){
        const b = Number(bids[p.id] ?? 0);
        const m = Number(game.tempMade[p.id] ?? 0);
        p.score += delta(b,m,game.currentRound);
      }
      // cleanup et suite
      delete game.savedBids[game.currentRound];
      game.tempBids = {}; game.tempMade = {};
      // If it was last round -> finalize and go to results
      if (game.currentRound >= game.totalRounds){
        const lb = loadLB();
        for (const p of game.players){
          const key = p.name || 'Joueur';
          if (!lb[key]) lb[key] = { total:0, games:0 };
          lb[key].total += p.score; lb[key].games += 1;
        }
        saveLB(lb);
        saveGame(game);
        location.href='results.html';
        return;
      } else {
        // Otherwise: set up next round interstitial
        game.nextRound = game.currentRound + 1;
        game.subphase = 'round_start';
        saveGame(game);
        render();
      }
    };
    actions.appendChild(back); actions.appendChild(valid);
    content.appendChild(actions);

    updateValidateBtn();
  }
}

function updateValidateBtn(){
  const btn = document.getElementById('vbtn');
  if (!btn) return;
  let sum = 0;
  for (const p of game.players){ sum += Number(game.tempMade && game.tempMade[p.id]!==undefined ? game.tempMade[p.id] : 0); }
  const ok = (sum === game.currentRound);
  btn.disabled = !ok;
  btn.classList.toggle('disabled', !ok);
}

render();

// helper escape
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

</script>
</body>
</html>
